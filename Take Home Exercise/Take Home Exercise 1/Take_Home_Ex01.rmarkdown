---
title: "Take-home Exercise 1: Geospatial Analytics for Public Good"
---

# Setting the scene

The locations of businesses and firms are central to urban development, influencing economic growth, job creation, and the availability of resources and services for residents and other businesses. Strategic locations provide competitive advantages, access to talent and infrastructure, and impact brand image and market positioning, while also shaping the city’s overall character and functionality by fostering specialized districts and facilitating efficient supply chains and employee commutes.

Studying the spatio-temporal patterns of businesses and firms is crucial for urban development because it reveals how economic activity and urban forms evolve, enabling better urban planning, promoting sustainability, identifying urban inefficiencies, and enhancing quality of life. By understanding where and when businesses locate and operate, urban planners can design cities more effectively, anticipate growth, ensure resource efficiency, and tailor infrastructure to support economic vitality and community well-being.

# Objectives

In this take-home exercise, we are interested to investigate the spatial and spatio-temporal patterns of new businesses and firms established in Singapore for the first six months of 2025

The specific objectives of this take-home exercise are as follows:

-   To identify the “where” and “when” of new business entities, revealing clusters, patterns, and trends that are crucial for informed urban planning, resource allocation, and economic development.

-   To identify complex interaction patterns and emergent phenomena in the distribution of new businesses beyond simple proximity or density, such as clustering of related businesses, the influence of past trends on future locations, and the overall structural development of commercial areas, which are crucial for scientific urban planning and policy-making.

By understanding where businesses are located and how their distribution changes over time, urban planners nad managers can unlock spatial intelligence, optimize operations, and create effective strategies to attract investment and promote sustainable growth.

# Submission

## Reading data

```{r}
library(tcltk)
```

```{r}
pacman::p_load(tidyverse, sf, tmap, httr, terra, spatstat, rvest, tidyverse, stpp, sparr)
```

```{r}
setwd("/Users/zishengwong/R Coding/ISSS626 Geospatial Analytics/Take Home Exercise/Take Home Exercise 1")
folder_path <- "./data/aspatial/acra"
```

```{r}
file_list <- list.files(path = folder_path,
                        pattern = "^ACRA*.*\\.csv$",
                        full.names = TRUE)

acra_data <- file_list %>%
  map_dfr(read_csv)

#write_rds(acra_data,
#          "data/rds/acra_data.rds")
```

```{r}
acra_data <- read_rds("./data/rds/acra_data.rds")
```

```{r}
library(tidyverse)

# Count number of records by SSIC code
ssic_counts <- acra_data %>%
  count(primary_ssic_code, sort = TRUE)

# View top 20 SSIC codes with most records
head(ssic_counts, 20)
```

## 1. Restaurant Business

### Tidying Data

```{r}
rest_biz_56111 <- acra_data %>%
  select(1:24) %>%
  filter(primary_ssic_code == 56111) %>%
  rename(date = registration_incorporation_date) %>%
  mutate(date = as.Date(date),
         YEAR = year(date),
         MONTH_NUM = month(date),
         MONTH_ABBR = month(date,
                            label = TRUE,
                            abbr = TRUE)) %>%
  mutate(
    postal_code = str_pad(postal_code,
                          width = 6, side = "left", pad = "0")) %>%
  filter(YEAR == 2025)
```

### Geocoding

```{r}
postcodes <- unique(rest_biz_56111$postal_code)
found <- data.frame()
not_found <- data.frame(postcode = character())
url <- "https://onemap.gov.sg/api/common/elastic/search"
```

```{r}
for (pc in postcodes) {
  query <- list(
    searchVal = pc,
    returnGeom = "Y",
    getAddrDetails = "Y",
    pageNum = "1"
  )
  res <- GET(url, query = query)
  json <- content(res)
  if (json$found != 0) {
    df <- as.data.frame(json$results, stringAsFactors = FALSE)
    df$input_postcode <- pc
    found <- bind_rows(found, df)
  } else {
    not_found <- bind_rows(not_found, data.frame(postcode = pc))
  }
}
```

```{r}
rest_biz_56111 = rest_biz_56111 %>%
  left_join(found,
            by = c('postal_code' = 'POSTAL'),
            relationship = "many-to-many")
```

```{r}
rest_biz_56111_sf <- st_as_sf(rest_biz_56111,
                         coords = c("X","Y"),
                         crs=3414)
```

Save rest_biz_56111_sf file

```{r}
#write_rds(rest_biz_56111_sf, "data/rds/rest_biz_56111_sf.rds")
```

### Understanding Data

```{r}
rest_biz_56111_sf <- read_rds("data/rds/rest_biz_56111_sf.rds")
```

```{r}
head(rest_biz_56111_sf)
```

Number of businesses

```{r}
# number of businesses
nrow(rest_biz_56111_sf)
```

Plotting data

```{r}
plot(rest_biz_56111_sf)
```

### Convert sf dataframe to ppp class

```{r}
rest_biz_56111_ppp <- as.ppp(rest_biz_56111_sf)

class(rest_biz_56111_ppp)
```

```{r}
#summary(rest_biz_56111_ppp)
```

### Create owin object

```{r}
mpsz_cl <- read_rds("data/rds/mpsz_cl.rds")
```

```{r}
sg_owin <- as.owin(mpsz_cl)
```

```{r}
plot(sg_owin)
```

### Combine point events object and owin object

```{r}
rest_biz_56111_ppp = rest_biz_56111_ppp[sg_owin]
```

```{r}
rest_biz_56111_ppp
```

### Clark-Evan Test for Nearest Neighbour Analysis

Without CSR

```{r}
clarkevans.test(rest_biz_56111_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
```

With CSR

```{r}
clarkevans.test(rest_biz_56111_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                method="MonteCarlo",
                nsim=99)
```

Taking a 95% confidence level, the Clark-Evans test showed that p-value were consistently below the threshold \< 0.05, indicating that restaurants are not randomly distributed.

### Kernel Density Estimation

```{r}
rest_biz_56111_ppp_km <- rescale.ppp(
  rest_biz_56111_ppp, 1000, "km")
```

```{r}
rest_kde_SG_diggle <- density(
  rest_biz_56111_ppp_km,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
```

```{r}
plot(rest_kde_SG_diggle)
```

```{r}
summary(rest_kde_SG_diggle)
```

```{r}
bw <- bw.diggle(rest_biz_56111_ppp_km)
bw
```

### 2nd Order Spatial Point Pattern Analysis

#### Using K-Function

Computing K-Function estimate

```{r}
K_rest = Kest(rest_biz_56111_ppp, correction = "Ripley")
plot(K_rest, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
K_rest.csr <- envelope(rest_biz_56111_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_rest.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

#### Using L-Function

Computing L Function estimate

```{r}
L_rest = Lest(rest_biz_56111_ppp, correction = "Ripley")
plot(L_rest, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

```{r}
L_rest.csr <- envelope(rest_biz_56111_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_rest.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

### Spatio-Temporal Point Patterns Analysis

Overall Plot:

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(rest_biz_56111_sf) +
  tm_dots()
```

#### Visualizing geographic distribution of restaurants by month

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(rest_biz_56111_sf) +
  tm_dots(size=0.1) +
  tm_facets(by="MONTH_ABBR", 
            free.coords=FALSE, 
            drop.units = TRUE)
```

#### Computing STKDE by Month

```{r}
rest_month <- rest_biz_56111_sf %>%
  select(MONTH_NUM)
```

#### Creating PPP

```{r}
rest_month_ppp <- as.ppp(rest_month)
rest_month_ppp
```

```{r}
summary(rest_month_ppp)
```

```{r}
any(duplicated(rest_month_ppp))
```

#### Including Owin object

```{r}
rest_month_owin <- rest_month_ppp[sg_owin]
summary(rest_month_owin)
```

```{r}
plot(rest_month_owin)
```

#### Compute Spatio-temporal KDE

```{r}
rest_kde <- spattemp.density(rest_month_owin)
summary(rest_kde)
```

#### Plotting spatio-temporal KDE object

```{r}
tims <- c(1,2,3,4,5,6,7)
par(mfcol=c(2,4))
for(i in tims){ 
  plot(rest_kde, i, 
       override.par=FALSE, 
       fix.range=TRUE, 
       main=paste("KDE at month",i))
}
```

#### stpp Method

```{r}
rest_coords <- st_coordinates(rest_biz_56111_sf)
```

```{r}
rest_df <- data.frame(
  x = rest_coords[, 1],  
  y = rest_coords[, 2],
  t = rest_biz_56111_sf$`date`)
```

```{r}
rest_stpp <- as.3dpoints(rest_df)
```

```{r}
plot(rest_stpp)
```

#### Computing spatio-temporal k-function

```{r}
rest_stik <- STIKhat(rest_stpp)
```

```{r}
plotK(rest_stik)
```

## 2. IT Consultancy Business

### Tidying Data

```{r}
IT_biz_62021 <- acra_data %>%
  select(1:24) %>%
  filter(primary_ssic_code == 62021) %>%
  rename(date = registration_incorporation_date) %>%
  mutate(date = as.Date(date),
         YEAR = year(date),
         MONTH_NUM = month(date),
         MONTH_ABBR = month(date,
                            label = TRUE,
                            abbr = TRUE)) %>%
  mutate(
    postal_code = str_pad(postal_code,
                          width = 6, side = "left", pad = "0")) %>%
  filter(YEAR == 2025)
```

### Geocoding

```{r}
postcodes <- unique(IT_biz_62021$postal_code)
found <- data.frame()
not_found <- data.frame(postcode = character())
url <- "https://onemap.gov.sg/api/common/elastic/search"
```

```{r}
for (pc in postcodes) {
  query <- list(
    searchVal = pc,
    returnGeom = "Y",
    getAddrDetails = "Y",
    pageNum = "1"
  )
  res <- GET(url, query = query)
  json <- content(res)
  if (json$found != 0) {
    df <- as.data.frame(json$results, stringAsFactors = FALSE)
    df$input_postcode <- pc
    found <- bind_rows(found, df)
  } else {
    not_found <- bind_rows(not_found, data.frame(postcode = pc))
  }
}
```

```{r}
IT_biz_62021 = IT_biz_62021 %>%
  left_join(found,
            by = c('postal_code' = 'POSTAL'),
            relationship = "many-to-many")
```

```{r}
IT_biz_62021_sf <- st_as_sf(IT_biz_62021,
                         coords = c("X","Y"),
                         crs=3414)
```

Save IT_biz_62021_sf file

```{r}
#write_rds(IT_biz_62021_sf, "data/rds/IT_biz_62021_sf.rds")
```

### Understanding Data

```{r}
IT_biz_62021_sf <- read_rds("data/rds/IT_biz_62021_sf.rds")
```

```{r}
head(IT_biz_62021_sf)
```

Number of businesses

```{r}
# number of businesses
nrow(IT_biz_62021_sf)
```

Plotting data

```{r}
plot(IT_biz_62021_sf)
```

### Convert sf dataframe to ppp class

```{r}
IT_biz_62021_ppp <- as.ppp(IT_biz_62021_sf)

class(IT_biz_62021_ppp)
```

```{r}
summary(IT_biz_62021_ppp)
```

### Create owin object

```{r}
mpsz_cl <- read_rds("data/rds/mpsz_cl.rds")
```

```{r}
sg_owin <- as.owin(mpsz_cl)
```

```{r}
plot(sg_owin)
```

### Combine point events object and owin object

```{r}
IT_biz_62021_ppp = IT_biz_62021_ppp[sg_owin]
```

```{r}
IT_biz_62021_ppp
```

### Clark-Evan Test for Nearest Neighbour Analysis

Without CSR

```{r}
clarkevans.test(IT_biz_62021_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
```

With CSR

```{r}
clarkevans.test(IT_biz_62021_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                method="MonteCarlo",
                nsim=99)
```

Taking a 95% confidence level, the Clark-Evans test showed that p-value were consistently below the threshold \< 0.05, indicating that restaurants are not randomly distributed.

### Kernel Density Estimation

```{r}
IT_biz_62021_ppp_km <- rescale.ppp(
  IT_biz_62021_ppp, 1000, "km")
```

```{r}
it_kde_SG_diggle <- density(
  IT_biz_62021_ppp_km,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
```

```{r}
plot(it_kde_SG_diggle)
```

```{r}
summary(it_kde_SG_diggle)
```

```{r}
bw <- bw.diggle(IT_biz_62021_ppp_km)
bw
```

### 2nd Order Spatial Point Pattern Analysis

#### Using K-Function

Computing K-Function estimate

```{r}
K_it = Kest(IT_biz_62021_ppp, correction = "Ripley")
plot(K_it, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
K_it.csr <- envelope(IT_biz_62021_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_it.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

#### Using L-Function

Computing L Function estimate

```{r}
L_it = Lest(IT_biz_62021_ppp, correction = "Ripley")
plot(L_it, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

```{r}
L_it.csr <- envelope(IT_biz_62021_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_it.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

### Spatio-Temporal Point Patterns Analysis

Overall Plot:

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(IT_biz_62021_sf) +
  tm_dots()
```

#### Visualizing geographic distribution of restaurants by month

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(IT_biz_62021_sf) +
  tm_dots(size=0.1) +
  tm_facets(by="MONTH_ABBR", 
            free.coords=FALSE, 
            drop.units = TRUE)
```

#### Computing STKDE by Month

```{r}
it_month <- IT_biz_62021_sf %>%
  select(MONTH_NUM)
```

#### Creating PPP

```{r}
it_month_ppp <- as.ppp(it_month)
it_month_ppp
```

```{r}
summary(it_month_ppp)
```

```{r}
any(duplicated(it_month_ppp))
```

#### Including Owin object

```{r}
it_month_owin <- it_month_ppp[sg_owin]
summary(it_month_owin)
```

```{r}
plot(it_month_owin)
```

#### Compute Spatio-temporal KDE

```{r}
it_kde <- spattemp.density(it_month_owin)
summary(it_kde)
```

#### Plotting spatio-temporal KDE object

```{r}
tims <- c(1,2,3,4,5,6,7)
par(mfcol=c(2,4))
for(i in tims){ 
  plot(it_kde, i, 
       override.par=FALSE, 
       fix.range=TRUE, 
       main=paste("KDE at month",i))
}
```

#### stpp Method

```{r}
it_coords <- st_coordinates(IT_biz_62021_sf)
```

```{r}
it_df <- data.frame(
  x = it_coords[, 1],  
  y = it_coords[, 2],
  t = IT_biz_62021_sf$`date`)
```

```{r}
it_stpp <- as.3dpoints(it_df)
```

```{r}
plot(it_stpp)
```

#### Computing spatio-temporal k-function

```{r}
it_stik <- STIKhat(it_stpp)
```

```{r}
plotK(it_stik)
```

## 3. Clothing Retail Business

### Tidying Data

```{r}
ret_biz_47711 <- acra_data %>%
  select(1:24) %>%
  filter(primary_ssic_code == 47711) %>%
  rename(date = registration_incorporation_date) %>%
  mutate(date = as.Date(date),
         YEAR = year(date),
         MONTH_NUM = month(date),
         MONTH_ABBR = month(date,
                            label = TRUE,
                            abbr = TRUE)) %>%
  mutate(
    postal_code = str_pad(postal_code,
                          width = 6, side = "left", pad = "0")) %>%
  filter(YEAR == 2025)
```

### Geocoding

```{r}
postcodes <- unique(ret_biz_47711$postal_code)
found <- data.frame()
not_found <- data.frame(postcode = character())
url <- "https://onemap.gov.sg/api/common/elastic/search"
```

```{r}
for (pc in postcodes) {
  query <- list(
    searchVal = pc,
    returnGeom = "Y",
    getAddrDetails = "Y",
    pageNum = "1"
  )
  res <- GET(url, query = query)
  json <- content(res)
  if (json$found != 0) {
    df <- as.data.frame(json$results, stringAsFactors = FALSE)
    df$input_postcode <- pc
    found <- bind_rows(found, df)
  } else {
    not_found <- bind_rows(not_found, data.frame(postcode = pc))
  }
}
```

```{r}
ret_biz_47711 = ret_biz_47711 %>%
  left_join(found,
            by = c('postal_code' = 'POSTAL'),
            relationship = "many-to-many")
```

```{r}
ret_biz_47711_sf <- st_as_sf(ret_biz_47711,
                         coords = c("X","Y"),
                         crs=3414)
```

Save ff_biz_56121_sf file

```{r}
#write_rds(ff_biz_56121_sf, "data/rds/ret_biz_47711_sf.rds")
```

### Understanding Data

```{r}
ret_biz_47711_sf <- read_rds("data/rds/ret_biz_47711_sf.rds")
```

```{r}
head(ret_biz_47711_sf)
```

Number of businesses

```{r}
# number of businesses
nrow(ret_biz_47711_sf)
```

Plotting data

```{r}
plot(ret_biz_47711_sf)
```

### Convert sf dataframe to ppp class

```{r}
ret_biz_47711_ppp <- as.ppp(ret_biz_47711_sf)

class(ret_biz_47711_ppp)
```

```{r}
summary(ret_biz_47711_ppp)
```

### Create owin object

```{r}
mpsz_cl <- read_rds("data/rds/mpsz_cl.rds")
```

```{r}
sg_owin <- as.owin(mpsz_cl)
```

```{r}
plot(sg_owin)
```

### Combine point events object and owin object

```{r}
ret_biz_47711_ppp = ret_biz_47711_ppp[sg_owin]
```

```{r}
ret_biz_47711_ppp
```

### Clark-Evan Test for Nearest Neighbour Analysis

Without CSR

```{r}
clarkevans.test(ret_biz_47711_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
```

With CSR

```{r}
clarkevans.test(ret_biz_47711_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                method="MonteCarlo",
                nsim=99)
```

Taking a 95% confidence level, the Clark-Evans test showed that p-value were consistently below the threshold \< 0.05, indicating that restaurants are not randomly distributed.

### Kernel Density Estimation

```{r}
ret_biz_47711_ppp_km <- rescale.ppp(
  ret_biz_47711_ppp, 1000, "km")
```

```{r}
ret_kde_SG_diggle <- density(
  ret_biz_47711_ppp_km,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
```

```{r}
plot(ret_kde_SG_diggle)
```

```{r}
summary(ret_kde_SG_diggle)
```

```{r}
bw <- bw.diggle(ret_biz_47711_ppp_km)
bw
```

### 2nd Order Spatial Point Pattern Analysis

#### Using K-Function

Computing K-Function estimate

```{r}
K_ret = Kest(ret_biz_47711_ppp, correction = "Ripley")
plot(K_ret, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
K_ret.csr <- envelope(ret_biz_47711_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ret.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

#### Using L-Function

Computing L Function estimate

```{r}
L_ret = Lest(ret_biz_47711_ppp, correction = "Ripley")
plot(L_ret, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

```{r}
L_ret.csr <- envelope(ret_biz_47711_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ret.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

### Spatio-Temporal Point Patterns Analysis

Overall Plot:

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(ret_biz_47711_sf) +
  tm_dots()
```

#### Visualizing geographic distribution of restaurants by month

```{r}
tm_shape(mpsz_cl)+
  tm_polygons() +
tm_shape(ret_biz_47711_sf) +
  tm_dots(size=0.1) +
  tm_facets(by="MONTH_ABBR", 
            free.coords=FALSE, 
            drop.units = TRUE)
```

#### Computing STKDE by Month

```{r}
ret_month <- ret_biz_47711_sf %>%
  select(MONTH_NUM)
```

#### Creating PPP

```{r}
ret_month_ppp <- as.ppp(ret_month)
ret_month_ppp
```

```{r}
summary(ret_month_ppp)
```

```{r}
any(duplicated(ret_month_ppp))
```

#### Including Owin object

```{r}
ret_month_owin <- ret_month_ppp[sg_owin]
summary(ret_month_owin)
```

```{r}
plot(ret_month_owin)
```

#### Compute Spatio-temporal KDE

```{r}
ret_kde <- spattemp.density(ret_month_owin)
summary(ret_kde)
```

#### Plotting spatio-temporal KDE object

```{r}
tims <- c(1,2,3,4,5,6,7)
par(mfcol=c(2,4))
for(i in tims){ 
  plot(ret_kde, i, 
       override.par=FALSE, 
       fix.range=TRUE, 
       main=paste("KDE at month",i))
}
```

#### stpp Method

```{r}
ret_coords <- st_coordinates(ret_biz_47711_sf)
```

```{r}
ret_df <- data.frame(
  x = ret_coords[, 1],  
  y = ret_coords[, 2],
  t = ret_biz_47711_sf$`date`)
```

```{r}
ret_stpp <- as.3dpoints(ret_df)
```

```{r}
plot(ret_stpp)
```

#### Computing spatio-temporal k-function

```{r}
ret_stik <- STIKhat(ret_stpp)
```

```{r}
plotK(ret_stik)
```

